/*****
*
*   Class       MobileElementMovementEvent
*   Author      Lincoln Fellingham, Aviation Research Corporation
*   Date        December 4, 1992
*   Purpose     Event class used to schedule passenger movements though
*               a terminal
*
*****/
#include "stdafx.h"
#include "engine\movevent.h"
#include "common\elaptime.h"
#include "engine\mobile.h"
#include "term_err.h"
#include <iostream>
#include "common\CodeTimeTest.h"
#include "engine\terminal.h"
#include "common\states.h"

#include "Common\ARCException.h"
#include "Common\ARCExceptionEx.h"
#include "SimulationDiagnoseDelivery.h"
#include "../Common/ARCTracker.h"
#include "Engine/ARCportEngine.h"


// If move() returns TRUE, the mobile element has died and will be deleted.
int MobileElementMovementEvent::process (CARCportEngine *_pEngine )
{
	//if(!_pEngine->m_simBobileelemList.IsAlive(mobileElement))
	//	return 1;

	PLACE_METHOD_TRACK_STRING();
	if( mobileElement->getState() == Death )
		return 1;

	try 
	{
		if (!mobileElement->move (time,m_bNoLog))
		{
			//			delete mobileElement;
			mobileElement->setState( Death );
			mobileElement = NULL;

		}
	}  
	// all recoverable errors that affect 1 passenger are trapped here
	catch (ARCSimEngineException* sim_exception)
	{
		_pEngine->SendSimFormatMessage( sim_exception->getFormatErrorMsg() );
		delete sim_exception;
	}
	 catch (OnBoardSimEngineException* onboard_exeption)
	{
		OnBoardDiagnose* pDiagnose = 
			(OnBoardDiagnose*)onboard_exeption->GetDiagnose();
		DiagnoseDelivery()->DeliveryOnBoardDiagnose(pDiagnose);
		delete onboard_exeption;
	}
	return 1;
}


int MobileElementMovementEvent::kill (void)
{
    mobileElement->kill (time);
//	delete mobileElement;
	mobileElement = NULL;
    return 1;
}


ElapsedTime MobileElementMovementEvent::removeMoveEvent
    (MobileElement *anElement)
{
    ElapsedTime aTime = -1l;
	ElapsedTime prevEventTime = anElement->GetPrevEventTime();
	if( prevEventTime == -1l )
		return aTime;

	int nCount = m_pEventList->getCount();
	int nIdx = m_pEventList->FindFirstMatch( prevEventTime );
	if( nIdx < 0  )
		return aTime;
	
	for( int i=nIdx; i<nCount; i++ )
	{
		Event* pEventInList = m_pEventList->getItem( i );
		if( (long)(pEventInList->getTime()) != (long)prevEventTime  )
			break;

        if( pEventInList->getEventType() == MobileMovement)
		{

		    MobileElementMovementEvent *pMoveEvent = (MobileElementMovementEvent *)pEventInList;
			if( pMoveEvent->mobileElement == anElement)
			{
				aTime = pMoveEvent->time;
//				m_pEventList->deleteItem( nIdx );
				m_pEventList->deleteItem( i );
				break;
			}
		}
	}
    return aTime;
}


// remove all event which is generated by _pElement
void MobileElementMovementEvent::RemoveAllMobileElementEvent( MobileElement * _pElement )
{
	int nCount = m_pEventList->getCount();
	for( int i=nCount-1; i>=0; --i )
	{
		Event* pEventInList = m_pEventList->getItem( i );
		
        if( pEventInList->getEventType() == MobileMovement)
		{
		    MobileElementMovementEvent *pMoveEvent = (MobileElementMovementEvent *)pEventInList;
			if( pMoveEvent->mobileElement == _pElement )
			{
				m_pEventList->deleteItem( i );
				break;
			}
		}
	}
}
